--- a/Python/thread_pthread.h
+++ b/Python/thread_pthread.h
@@ -100,6 +100,19 @@
 #undef HAVE_SEM_CLOCKWAIT
 #endif
 
+/* When building against glibc headers older than 2.30, configure cannot
+ * detect sem_clockwait. Declare it as a weak symbol so it
+ * resolves to NULL on old glibc and to the real function on glibc 2.30+.
+ * This enables monotonic clock waits at runtime when available, preventing
+ * hangs when the system clock jumps backward (e.g., NTP sync). */
+#if defined(__linux__) && !defined(HAVE_SEM_CLOCKWAIT)
+#include <time.h>
+__attribute__((weak)) extern int sem_clockwait(sem_t *, clockid_t,
+                                               const struct timespec *);
+#define HAVE_SEM_CLOCKWAIT 1
+#define _Py_SEM_CLOCKWAIT_WEAK 1
+#endif
+
 /* Whether or not to use semaphores directly rather than emulating them with
  * mutexes and condition variables:
  */
@@ -516,38 +529,38 @@
         timeout = -1;
     }
 
-#ifdef HAVE_SEM_CLOCKWAIT
+#ifdef _Py_SEM_CLOCKWAIT_WEAK
+    int use_clockwait = (sem_clockwait != NULL);
+#else
+    int use_clockwait = 1;
+#endif
     struct timespec abs_timeout;
-    // Local scope for deadline
-    {
+    PyTime_t deadline = 0;
+    if (use_clockwait) {
         PyTime_t now;
         // silently ignore error: cannot report error to the caller
         (void)PyTime_MonotonicRaw(&now);
-        PyTime_t deadline = _PyTime_Add(now, timeout);
-        _PyTime_AsTimespec_clamp(deadline, &abs_timeout);
-    }
-#else
-    PyTime_t deadline = 0;
-    if (timeout > 0 && !intr_flag) {
+        PyTime_t dl = _PyTime_Add(now, timeout);
+        _PyTime_AsTimespec_clamp(dl, &abs_timeout);
+    } else if (timeout > 0 && !intr_flag) {
         deadline = _PyDeadline_Init(timeout);
     }
-#endif
 
     while (1) {
         if (timeout > 0) {
-#ifdef HAVE_SEM_CLOCKWAIT
-            status = fix_status(sem_clockwait(thelock, CLOCK_MONOTONIC,
-                                              &abs_timeout));
-#else
-            PyTime_t now;
-            // silently ignore error: cannot report error to the caller
-            (void)PyTime_TimeRaw(&now);
-            PyTime_t abs_time = _PyTime_Add(now, timeout);
+            if (use_clockwait) {
+                status = fix_status(sem_clockwait(thelock, CLOCK_MONOTONIC,
+                                                  &abs_timeout));
+            } else {
+                PyTime_t now;
+                // silently ignore error: cannot report error to the caller
+                (void)PyTime_TimeRaw(&now);
+                PyTime_t abs_time = _PyTime_Add(now, timeout);
 
-            struct timespec ts;
-            _PyTime_AsTimespec_clamp(abs_time, &ts);
-            status = fix_status(sem_timedwait(thelock, &ts));
-#endif
+                struct timespec ts;
+                _PyTime_AsTimespec_clamp(abs_time, &ts);
+                status = fix_status(sem_timedwait(thelock, &ts));
+            }
         }
         else if (timeout == 0) {
             status = fix_status(sem_trywait(thelock));
@@ -564,8 +577,7 @@
 
         // sem_clockwait() uses an absolute timeout, there is no need
         // to recompute the relative timeout.
-#ifndef HAVE_SEM_CLOCKWAIT
-        if (timeout > 0) {
+        if (!use_clockwait && timeout > 0) {
             /* wait interrupted by a signal (EINTR): recompute the timeout */
             timeout = _PyDeadline_Get(deadline);
             if (timeout < 0) {
@@ -573,18 +585,13 @@
                 break;
             }
         }
-#endif
     }
 
     /* Don't check the status if we're stopping because of an interrupt.  */
     if (!(intr_flag && status == EINTR)) {
         if (timeout > 0) {
             if (status != ETIMEDOUT) {
-#ifdef HAVE_SEM_CLOCKWAIT
-                CHECK_STATUS("sem_clockwait");
-#else
-                CHECK_STATUS("sem_timedwait");
-#endif
+                CHECK_STATUS(use_clockwait ? "sem_clockwait" : "sem_timedwait");
             }
         }
         else if (timeout == 0) {
