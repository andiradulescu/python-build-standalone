--- a/Python/thread_pthread.h
+++ b/Python/thread_pthread.h
@@ -87,6 +87,18 @@
 #endif
 #endif
 
+/* When building against glibc headers older than 2.30, configure cannot
+ * detect sem_clockwait. Declare it as a weak symbol so it
+ * resolves to NULL on old glibc and to the real function on glibc 2.30+.
+ * This enables monotonic clock waits at runtime when available, preventing
+ * hangs when the system clock jumps backward (e.g., NTP sync). */
+#if defined(__linux__) && !defined(HAVE_SEM_CLOCKWAIT)
+#include <time.h>
+__attribute__((weak)) extern int sem_clockwait(sem_t *, clockid_t,
+                                               const struct timespec *);
+#define HAVE_SEM_CLOCKWAIT 1
+#define _Py_SEM_CLOCKWAIT_WEAK 1
+#endif
 
 /* Whether or not to use semaphores directly rather than emulating them with
  * mutexes and condition variables:
@@ -443,9 +455,7 @@
     sem_t *thelock = (sem_t *)lock;
     int status, error = 0;
     struct timespec ts;
-#ifndef HAVE_SEM_CLOCKWAIT
     _PyTime_t deadline = 0;
-#endif
 
     (void) error; /* silence unused-but-set-variable warning */
     dprintf(("PyThread_acquire_lock_timed(%p, %lld, %d) called\n",
@@ -455,29 +465,35 @@
         Py_FatalError("Timeout larger than PY_TIMEOUT_MAX");
     }
 
-    if (microseconds > 0) {
-#ifdef HAVE_SEM_CLOCKWAIT
-        monotonic_abs_timeout(microseconds, &ts);
+#ifdef _Py_SEM_CLOCKWAIT_WEAK
+    int use_clockwait = (sem_clockwait != NULL);
 #else
-        MICROSECONDS_TO_TIMESPEC(microseconds, ts);
+    int use_clockwait = 1;
+#endif
 
-        if (!intr_flag) {
-            /* cannot overflow thanks to (microseconds > PY_TIMEOUT_MAX)
-               check done above */
-            _PyTime_t timeout = _PyTime_FromNanoseconds(microseconds * 1000);
-            deadline = _PyTime_GetMonotonicClock() + timeout;
+    if (microseconds > 0) {
+        if (use_clockwait) {
+            monotonic_abs_timeout(microseconds, &ts);
+        } else {
+            MICROSECONDS_TO_TIMESPEC(microseconds, ts);
+
+            if (!intr_flag) {
+                /* cannot overflow thanks to (microseconds > PY_TIMEOUT_MAX)
+                   check done above */
+                _PyTime_t timeout = _PyTime_FromNanoseconds(microseconds * 1000);
+                deadline = _PyTime_GetMonotonicClock() + timeout;
+            }
         }
-#endif
     }
 
     while (1) {
         if (microseconds > 0) {
-#ifdef HAVE_SEM_CLOCKWAIT
-            status = fix_status(sem_clockwait(thelock, CLOCK_MONOTONIC,
-                                              &ts));
-#else
-            status = fix_status(sem_timedwait(thelock, &ts));
-#endif
+            if (use_clockwait) {
+                status = fix_status(sem_clockwait(thelock, CLOCK_MONOTONIC,
+                                                  &ts));
+            } else {
+                status = fix_status(sem_timedwait(thelock, &ts));
+            }
         }
         else if (microseconds == 0) {
             status = fix_status(sem_trywait(thelock));
@@ -494,8 +510,7 @@
 
         // sem_clockwait() uses an absolute timeout, there is no need
         // to recompute the relative timeout.
-#ifndef HAVE_SEM_CLOCKWAIT
-        if (microseconds > 0) {
+        if (!use_clockwait && microseconds > 0) {
             /* wait interrupted by a signal (EINTR): recompute the timeout */
             _PyTime_t dt = deadline - _PyTime_GetMonotonicClock();
             if (dt < 0) {
@@ -516,18 +531,13 @@
                 microseconds = 0;
             }
         }
-#endif
     }
 
     /* Don't check the status if we're stopping because of an interrupt.  */
     if (!(intr_flag && status == EINTR)) {
         if (microseconds > 0) {
             if (status != ETIMEDOUT) {
-#ifdef HAVE_SEM_CLOCKWAIT
-                CHECK_STATUS("sem_clockwait");
-#else
-                CHECK_STATUS("sem_timedwait");
-#endif
+                CHECK_STATUS(use_clockwait ? "sem_clockwait" : "sem_timedwait");
             }
         }
         else if (microseconds == 0) {
